#!/usr/bin/env bash
# pkg — source-based package manager (recipes declarativas) — v2.2.0
# Principais evoluções nesta versão:
# - deps separadas: bdeps (build) e rdeps (runtime) + compat com deps=
# - rebuild revdeps por ABI/SONAME melhorado (SONAME removido + fallback conservador)
# - DB/instalação mais robusta: ownership de arquivos (evita remover arquivo de outro pkg)
# - índice local "inteligente": busca com filtros (name:, cat:, stage:, dep:)
# - UX/ops: upgrade com waves+locks, check, verify, explain, hooks, métricas
# - sysroot/target toolchain (modo opcional por env): PKG_TARGET, PKG_SYSROOT
#
# Licença: MIT
set -Eeuo pipefail
IFS=$'\n\t'

VERSION="2.2.0"

: "${PKG_HOME:=${HOME}/.local/share/pkg}"
: "${PKG_PREFIX:=${HOME}/.local/pkg}"
: "${PKG_RECIPES:=${PKG_HOME}/recipes}"
: "${PKG_DISTFILES:=${PKG_HOME}/distfiles}"
: "${PKG_SOURCES:=${PKG_HOME}/sources}"
: "${PKG_BUILD_ROOT:=${PKG_HOME}/build}"
: "${PKG_DB:=${PKG_HOME}/db}"
: "${PKG_LOGS:=${PKG_HOME}/logs}"
: "${PKG_GRAPH:=${PKG_HOME}/graph}"
: "${PKG_LOCKS:=${PKG_HOME}/locks}"
: "${PKG_WORLD:=${PKG_HOME}/world}"
: "${PKG_INDEX:=${PKG_HOME}/index.tsv}"
: "${PKG_OWNERS:=${PKG_HOME}/owners.tsv}"
: "${PKG_HOOKS:=${PKG_HOME}/hooks}"
: "${PKG_JOBS:=$(getconf _NPROCESSORS_ONLN 2>/dev/null || echo 2)}"
: "${PKG_COLOR:=1}"
: "${PKG_SKIP_SHA256:=0}"
: "${PKG_DRY_RUN:=0}"
: "${PKG_CATEGORY:=}"
: "${PKG_ASSUME_YES:=0}"
: "${PKG_REBUILD_POLICY:=auto}"     # auto|never
: "${PKG_WAVES:=toolchain,libs,apps}" # ordem de ondas no upgrade (categorias heurísticas)
: "${PKG_TARGET:=}"                  # ex: x86_64-linux-musl
: "${PKG_SYSROOT:=}"                 # ex: $PKG_PREFIX/$PKG_TARGET/sysroot (absoluto recomendado)

LOCK_FILE="${PKG_HOME}/.lock"

if [[ "${PKG_COLOR}" == "1" ]] && [[ -t 1 ]]; then
  C_RED=$'\033[31m'; C_GRN=$'\033[32m'; C_YLW=$'\033[33m'; C_BLU=$'\033[34m'; C_DIM=$'\033[2m'; C_RST=$'\033[0m'
else
  C_RED=""; C_GRN=""; C_YLW=""; C_BLU=""; C_DIM=""; C_RST=""
fi

now() { date +%Y-%m-%dT%H:%M:%S%z; }
ts_epoch() { date +%s; }
log()   { printf "%s\n" "${C_BLU}[pkg]${C_RST} $*"; }
ok()    { printf "%s\n" "${C_GRN}[ok]${C_RST} $*"; }
warn()  { printf "%s\n" "${C_YLW}[warn]${C_RST} $*" >&2; }
die()   { printf "%s\n" "${C_RED}[erro]${C_RST} $*" >&2; exit 1; }

usage() {
  cat <<'EOF'
pkg — source-based package manager (recipes declarativas)

Comandos:
  pkg init
  pkg index [--refresh]
  pkg fetch <pkg>|@world [--sources] [--skip-sha256] [--dry-run]
  pkg install <pkg>|@world [--dry-run] [--skip-sha256]
  pkg update  <pkg>|@world [--dry-run] [--skip-sha256]
  pkg upgrade [@world] [--waves toolchain,libs,apps] [--no-rebuild] [--dry-run]
  pkg rebuild <pkg> [--revdeps] [--all-revdeps] [--dry-run]
  pkg remove  <pkg> [--dry-run]
  pkg list
  pkg info <pkg>
  pkg search <query>            (suporta filtros: name:, cat:, stage:, dep:)
  pkg explain <pkg> [--tree]
  pkg plan <pkg>|@world
  pkg autoremove [--dry-run]
  pkg clean <pkg>|all
  pkg check [<pkg>|@world]
  pkg verify [distfiles|prefix|all]
  pkg doctor
  pkg env

Atalhos:
  pkg -i <pkg>     install
  pkg -u <pkg>     update
  pkg -r <pkg>     remove
  pkg -l           list
  pkg -I <pkg>     info
  pkg -s <term>    search
  pkg -n ...       dry-run
  pkg -S ...       skip sha256

Recipes:
  $PKG_RECIPES/<categoria>/<nome>.recipe

Formato (INI simples):
  name=zlib
  version=1.3.1
  url=https://...
  sha256=...
  stage=autotools|cmake|meson|make|generic|binutils|toolchain-bootstrap|libc-musl|toolchain-final
  bdeps=dep1 dep2
  rdeps=dep3 dep4
  # compat: deps=... equivale a rdeps=...

Toolchain (opcional):
  export PKG_TARGET=x86_64-linux-musl
  export PKG_SYSROOT=$PKG_PREFIX/$PKG_TARGET/sysroot

EOF
}

mkdirs() {
  mkdir -p "$PKG_HOME" "$PKG_PREFIX" "$PKG_RECIPES" "$PKG_DISTFILES" "$PKG_SOURCES" "$PKG_BUILD_ROOT" \
           "$PKG_DB" "$PKG_LOGS" "$PKG_GRAPH" "$PKG_LOCKS" "$PKG_HOOKS"
  touch "$PKG_WORLD" 2>/dev/null || true
  touch "$PKG_OWNERS" 2>/dev/null || true
}

lock_acquire() {
  mkdirs
  exec 9>"$LOCK_FILE"
  flock -n 9 || die "Outra execução está ativa (lock: $LOCK_FILE)"
}

have_cmd() { command -v "$1" >/dev/null 2>&1; }
need_cmd() { have_cmd "$1" || die "Comando obrigatório não encontrado: $1"; }
tmpdir_new() { mktemp -d "${PKG_BUILD_ROOT}/.tmp.XXXXXX"; }

sha256_of() {
  if have_cmd sha256sum; then sha256sum "$1" | awk '{print $1}'
  elif have_cmd shasum; then shasum -a 256 "$1" | awk '{print $1}'
  else die "sha256sum/shasum não encontrado."
  fi
}

fetch_url() {
  local url="$1" out="$2"
  if have_cmd curl; then
    curl -L --fail --retry 3 --connect-timeout 15 -o "$out" "$url"
  elif have_cmd wget; then
    wget -O "$out" "$url"
  else
    die "curl ou wget é necessário."
  fi
}

extract_archive() {
  local archive="$1" dest="$2"
  mkdir -p "$dest"
  case "$archive" in
    *.tar.gz|*.tgz)   tar -xzf "$archive" -C "$dest" ;;
    *.tar.bz2|*.tbz2) tar -xjf "$archive" -C "$dest" ;;
    *.tar.xz|*.txz)   tar -xJf "$archive" -C "$dest" ;;
    *.tar.zst)        tar --zstd -xf "$archive" -C "$dest" ;;
    *.zip)            need_cmd unzip; unzip -q "$archive" -d "$dest" ;;
    *) die "Formato não suportado: $archive" ;;
  esac
}

RUN_ID="$(now)-$$"
RUN_LOG="${PKG_LOGS}/run-${RUN_ID}.log"
REGISTRY="${PKG_LOGS}/registry.jsonl"

registry() {
  local action="$1" pkg="${2:-}" extra="${3:-}"
  printf '{"ts":"%s","run":"%s","action":"%s","pkg":"%s","extra":"%s"}\n' \
    "$(now)" "$RUN_ID" "$action" "$pkg" "${extra//\"/\\\"}" >> "$REGISTRY" || true
}

start_logging() {
  exec > >(tee -a "$RUN_LOG") 2>&1
  log "run_id=$RUN_ID"
  log "log=$RUN_LOG"
}

confirm() {
  local q="$1"
  if [[ "$PKG_ASSUME_YES" == "1" ]]; then return 0; fi
  read -r -p "$q [Y/n] " ans || true
  [[ "${ans:-Y}" =~ ^[Yy]$ ]]
}

# ---------------- Recipes ----------------
recipe_find_path() {
  local pkg="$1"
  local forced="${PKG_CATEGORY:-}"
  local p
  if [[ -n "$forced" ]]; then
    p="${PKG_RECIPES}/${forced}/${pkg}.recipe"
    [[ -f "$p" ]] || die "Receita não encontrada em '${forced}': $p"
    echo "$p"; return
  fi
  local matches=()
  while IFS= read -r p; do matches+=("$p"); done < <(find "$PKG_RECIPES" -type f -name "${pkg}.recipe" 2>/dev/null | sort || true)
  [[ "${#matches[@]}" -gt 0 ]] || die "Receita não encontrada: ${pkg}.recipe"
  if [[ "${#matches[@]}" -gt 1 ]]; then
    warn "Receita ambígua:"
    printf "  - %s\n" "${matches[@]}"
    die "Defina PKG_CATEGORY=<categoria>."
  fi
  echo "${matches[0]}"
}

# carregados:
# R_NAME R_VERSION R_URL R_SHA256 R_STAGE R_BDEPS[] R_RDEPS[] R_CATEGORY R_PATH
recipe_load() {
  local pkg="$1"
  local path; path="$(recipe_find_path "$pkg")"
  local category; category="$(basename "$(dirname "$path")")"

  local name="" version="" url="" sha256="" stage="generic"
  local bdeps_line="" rdeps_line="" deps_compat=""
  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%$'\r'}"
    line="${line%%#*}"
    line="${line%"${line##*[![:space:]]}"}"
    line="${line#"${line%%[![:space:]]*}"}"
    [[ -n "$line" ]] || continue
    [[ "$line" == *"="* ]] || die "Linha inválida em $path: $line"
    local k="${line%%=*}"; local v="${line#*=}"
    k="${k%"${k##*[![:space:]]}"}"; k="${k#"${k%%[![:space:]]*}"}"
    v="${v%"${v##*[![:space:]]}"}"; v="${v#"${v%%[![:space:]]*}"}"
    case "$k" in
      name) name="$v" ;;
      version) version="$v" ;;
      url) url="$v" ;;
      sha256) sha256="$v" ;;
      stage) stage="$v" ;;
      bdeps) bdeps_line="$v" ;;
      rdeps) rdeps_line="$v" ;;
      deps) deps_compat="$v" ;;
      *) die "Chave desconhecida em $path: $k" ;;
    esac
  done < "$path"

  [[ -n "$name" && "$name" == "$pkg" ]] || die "Recipe $path inválida: name deve ser '$pkg'"
  [[ -n "$version" ]] || die "Recipe $path inválida: faltou version"
  [[ -n "$url" ]] || die "Recipe $path inválida: faltou url"

  # compat: deps=... -> rdeps
  if [[ -n "$deps_compat" && -z "$rdeps_line" ]]; then rdeps_line="$deps_compat"; fi

  R_NAME="$name"; R_VERSION="$version"; R_URL="$url"; R_SHA256="$sha256"; R_STAGE="$stage"; R_CATEGORY="$category"; R_PATH="$path"
  R_BDEPS=(); R_RDEPS=()
  [[ -n "$bdeps_line" ]] && read -r -a R_BDEPS <<< "$bdeps_line"
  [[ -n "$rdeps_line" ]] && read -r -a R_RDEPS <<< "$rdeps_line"
}

distfile_path() { echo "${PKG_DISTFILES}/${R_NAME}-${R_VERSION}-$(basename "$R_URL")"; }
source_cache_dir() { echo "${PKG_SOURCES}/${R_NAME}-${R_VERSION}"; }
pkg_dir() { echo "${PKG_DB}/$1"; }
pkg_is_installed() { [[ -f "$(pkg_dir "$1")/manifest.txt" ]]; }
installed_version() { cat "$(pkg_dir "$1")/version" 2>/dev/null || true; }

# ---------------- Locks ----------------
lock_path() { echo "${PKG_LOCKS}/$1.lock"; }
lock_get() { [[ -f "$(lock_path "$1")" ]] && cat "$(lock_path "$1")"; }
lock_set() { [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] lock $1=$2"; return; }; printf "%s\n" "$2" > "$(lock_path "$1")"; }
lock_rm() { [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] unlock $1"; return; }; rm -f "$(lock_path "$1")"; }

effective_version() {
  local pkg="$1"
  local v; v="$(lock_get "$pkg" 2>/dev/null || true)"
  if [[ -n "$v" ]]; then echo "$v"; else recipe_load "$pkg"; echo "$R_VERSION"; fi
}
needs_update() {
  local pkg="$1"
  local cur; cur="$(installed_version "$pkg")"
  local eff; eff="$(effective_version "$pkg")"
  [[ -n "$cur" ]] || return 0
  [[ "$cur" != "$eff" ]]
}
is_locked() { [[ -n "$(lock_get "$1" 2>/dev/null || true)" ]]; }

# ---------------- Graph: deps + reverse-deps (runtime-only base) ----------------
graph_deps_file() { echo "${PKG_GRAPH}/deps.${1}.txt"; }
graph_revdeps_file() { echo "${PKG_GRAPH}/revdeps.${1}.txt"; }

graph_rebuild() {
  mkdirs
  rm -f "$PKG_GRAPH"/deps.*.txt "$PKG_GRAPH"/revdeps.*.txt 2>/dev/null || true

  local r pkg
  while IFS= read -r r; do
    pkg="$(basename "$r" .recipe)"
    recipe_load "$pkg"
    # base graph usa rdeps (para reverse-deps de runtime). build deps são tratados no planner.
    printf "%s\n" "${R_RDEPS[@]:-}" | tr ' ' '\n' | sed '/^$/d' > "$(graph_deps_file "$pkg")"
  done < <(find "$PKG_RECIPES" -type f -name "*.recipe" 2>/dev/null | sort)

  local all=()
  while IFS= read -r r; do all+=("$(basename "$r" .recipe)"); done < <(find "$PKG_RECIPES" -type f -name "*.recipe" 2>/dev/null | sort)

  local a d
  for a in "${all[@]}"; do : > "$(graph_revdeps_file "$a")"; done
  for a in "${all[@]}"; do
    while IFS= read -r d; do
      [[ -n "$d" ]] || continue
      echo "$a" >> "$(graph_revdeps_file "$d")"
    done < "$(graph_deps_file "$a")"
  done
  for a in "${all[@]}"; do sort -u -o "$(graph_revdeps_file "$a")" "$(graph_revdeps_file "$a")" 2>/dev/null || true; done
}

# ---------------- Planner com detecção de ciclo (bdeps+rdeps) ----------------
# mode:
#   install/update/rebuild: inclui bdeps + rdeps
#   runtime: inclui apenas rdeps (útil para explain simples)
declare -A _st=()
declare -a _stack=()
declare -a _order=()
stack_str() { local IFS=" -> "; echo "${_stack[*]}"; }

dfs_plan() {
  local pkg="$1" mode="$2"
  local s="${_st[$pkg]:-0}"
  if [[ "$s" -eq 2 ]]; then return; fi
  if [[ "$s" -eq 1 ]]; then
    _stack+=("$pkg")
    die "Ciclo de dependências: $(stack_str)"
  fi
  _st["$pkg"]=1
  _stack+=("$pkg")

  recipe_load "$pkg"
  local d
  if [[ "$mode" == "runtime" ]]; then
    for d in "${R_RDEPS[@]:-}"; do dfs_plan "$d" "$mode"; done
  else
    for d in "${R_BDEPS[@]:-}"; do dfs_plan "$d" "$mode"; done
    for d in "${R_RDEPS[@]:-}"; do dfs_plan "$d" "$mode"; done
  fi

  unset '_stack[${#_stack[@]}-1]'
  _st["$pkg"]=2
  _order+=("$pkg")
}

resolve_order() { local pkg="$1" mode="${2:-install}"; _st=(); _stack=(); _order=(); dfs_plan "$pkg" "$mode"; printf "%s\n" "${_order[@]}"; }

# ---------------- Templates + sysroot/target env ----------------
run_env_common() {
  export PATH="$PKG_PREFIX/bin:$PATH"
  export PKG_CONFIG_PATH="$PKG_PREFIX/lib/pkgconfig:$PKG_PREFIX/share/pkgconfig:${PKG_CONFIG_PATH:-}"
  export LD_LIBRARY_PATH="$PKG_PREFIX/lib:$PKG_PREFIX/lib64:${LD_LIBRARY_PATH:-}"
  export CMAKE_PREFIX_PATH="$PKG_PREFIX:${CMAKE_PREFIX_PATH:-}"

  if [[ -n "${PKG_TARGET}" ]]; then
    export TARGET="${PKG_TARGET}"
    export CC="${PKG_TARGET}-gcc"
    export CXX="${PKG_TARGET}-g++"
    export AR="${PKG_TARGET}-ar"
    export AS="${PKG_TARGET}-as"
    export LD="${PKG_TARGET}-ld"
    export RANLIB="${PKG_TARGET}-ranlib"
    export STRIP="${PKG_TARGET}-strip"
  fi

  if [[ -n "${PKG_SYSROOT}" ]]; then
    [[ "$PKG_SYSROOT" == /* ]] || die "PKG_SYSROOT deve ser absoluto."
    export SYSROOT="${PKG_SYSROOT}"
    export CFLAGS="${CFLAGS:-} --sysroot=${PKG_SYSROOT}"
    export CXXFLAGS="${CXXFLAGS:-} --sysroot=${PKG_SYSROOT}"
    export LDFLAGS="${LDFLAGS:-} --sysroot=${PKG_SYSROOT}"
  fi
}

template_generic() {
  local src="$1" bld="$2" destdir="$3"
  mkdir -p "$bld"
  pushd "$bld" >/dev/null
  run_env_common
  local args=(--prefix="$PKG_PREFIX")
  [[ -n "${PKG_TARGET}" ]] && args+=(--host="$PKG_TARGET")
  "$src/configure" "${args[@]}"
  make -j"$PKG_JOBS"
  make DESTDIR="$destdir" install
  popd >/dev/null
}
template_autotools() { template_generic "$@"; }

template_cmake() {
  need_cmd cmake
  local src="$1" bld="$2" destdir="$3"
  mkdir -p "$bld"
  run_env_common
  local args=(-DCMAKE_INSTALL_PREFIX="$PKG_PREFIX")
  [[ -n "${PKG_SYSROOT}" ]] && args+=(-DCMAKE_SYSROOT="$PKG_SYSROOT")
  [[ -n "${PKG_TARGET}" ]] && args+=(-DCMAKE_C_COMPILER="${PKG_TARGET}-gcc" -DCMAKE_CXX_COMPILER="${PKG_TARGET}-g++")
  cmake -S "$src" -B "$bld" "${args[@]}"
  cmake --build "$bld" -- -j"$PKG_JOBS"
  DESTDIR="$destdir" cmake --install "$bld"
}

template_meson() {
  need_cmd meson; need_cmd ninja
  local src="$1" bld="$2" destdir="$3"
  mkdir -p "$bld"
  run_env_common
  local args=(--prefix="$PKG_PREFIX")
  # cross file (básico) só quando PKG_TARGET setado
  local cross=""
  if [[ -n "${PKG_TARGET}" ]]; then
    cross="$(mktemp)"
    cat > "$cross" <<EOF
[binaries]
c = '${PKG_TARGET}-gcc'
cpp = '${PKG_TARGET}-g++'
ar = '${PKG_TARGET}-ar'
strip = '${PKG_TARGET}-strip'
[host_machine]
system = 'linux'
cpu_family = '$(echo "$PKG_TARGET" | cut -d- -f1)'
cpu = '$(echo "$PKG_TARGET" | cut -d- -f1)'
endian = 'little'
EOF
    args+=(--cross-file "$cross")
  fi
  meson setup "$bld" "$src" "${args[@]}"
  ninja -C "$bld" -j"$PKG_JOBS"
  DESTDIR="$destdir" ninja -C "$bld" install
  [[ -n "$cross" ]] && rm -f "$cross" 2>/dev/null || true
}

template_make() {
  local src="$1" bld="$2" destdir="$3"
  mkdir -p "$bld"
  rsync -a --delete "$src"/ "$bld"/
  run_env_common
  make -C "$bld" -j"$PKG_JOBS" PREFIX="$PKG_PREFIX"
  make -C "$bld" DESTDIR="$destdir" PREFIX="$PKG_PREFIX" install
}

template_binutils() {
  local src="$1" bld="$2" destdir="$3"
  mkdir -p "$bld"; pushd "$bld" >/dev/null
  run_env_common
  local args=(--prefix="$PKG_PREFIX" --disable-nls --disable-werror)
  [[ -n "${PKG_TARGET}" ]] && args+=(--target="$PKG_TARGET")
  [[ -n "${PKG_SYSROOT}" ]] && args+=(--with-sysroot="$PKG_SYSROOT")
  "$src/configure" "${args[@]}"
  make -j"$PKG_JOBS"
  make DESTDIR="$destdir" install
  popd >/dev/null
}

template_gcc_bootstrap() {
  local src="$1" bld="$2" destdir="$3"
  mkdir -p "$bld"; pushd "$bld" >/dev/null
  run_env_common
  local args=(--prefix="$PKG_PREFIX" --disable-multilib --disable-nls --disable-werror --enable-languages=c)
  [[ -n "${PKG_TARGET}" ]] && args+=(--target="$PKG_TARGET")
  [[ -n "${PKG_SYSROOT}" ]] && args+=(--with-sysroot="$PKG_SYSROOT")
  "$src/configure" "${args[@]}"
  make -j"$PKG_JOBS" all-gcc all-target-libgcc
  make DESTDIR="$destdir" install-gcc install-target-libgcc
  popd >/dev/null
}

template_musl() {
  local src="$1" bld="$2" destdir="$3"
  mkdir -p "$bld"
  rsync -a --delete "$src"/ "$bld"/
  pushd "$bld" >/dev/null
  run_env_common
  ./configure --prefix="$PKG_PREFIX"
  make -j"$PKG_JOBS"
  make DESTDIR="$destdir" install
  popd >/dev/null
}

template_gcc_final() {
  local src="$1" bld="$2" destdir="$3"
  mkdir -p "$bld"; pushd "$bld" >/dev/null
  run_env_common
  local args=(--prefix="$PKG_PREFIX" --disable-multilib --disable-nls --disable-werror --enable-languages=c,c++)
  [[ -n "${PKG_TARGET}" ]] && args+=(--target="$PKG_TARGET")
  [[ -n "${PKG_SYSROOT}" ]] && args+=(--with-sysroot="$PKG_SYSROOT")
  "$src/configure" "${args[@]}"
  make -j"$PKG_JOBS"
  make DESTDIR="$destdir" install
  popd >/dev/null
}

run_template() {
  local stage="$1" src="$2" bld="$3" destdir="$4"
  case "$stage" in
    generic) template_generic "$src" "$bld" "$destdir" ;;
    autotools) template_autotools "$src" "$bld" "$destdir" ;;
    cmake) template_cmake "$src" "$bld" "$destdir" ;;
    meson) template_meson "$src" "$bld" "$destdir" ;;
    make) template_make "$src" "$bld" "$destdir" ;;
    binutils) template_binutils "$src" "$bld" "$destdir" ;;
    toolchain-bootstrap) template_gcc_bootstrap "$src" "$bld" "$destdir" ;;
    libc-musl) template_musl "$src" "$bld" "$destdir" ;;
    toolchain-final) template_gcc_final "$src" "$bld" "$destdir" ;;
    *) die "stage desconhecido: $stage" ;;
  esac
}

# ---------------- ABI/SONAME + DT_NEEDED ----------------
elf_tool() { have_cmd readelf && echo "readelf" || (have_cmd objdump && echo "objdump" || echo ""); }

elf_dyn_dump() {
  local f="$1"
  local tool; tool="$(elf_tool)"
  [[ -n "$tool" ]] || return 1
  if [[ "$tool" == "readelf" ]]; then readelf -d "$f" 2>/dev/null || return 1
  else objdump -p "$f" 2>/dev/null || return 1
  fi
}

elf_collect_abi() {
  local root="$1" out_sonames="$2" out_needed="$3" out_rpaths="$4"
  : > "$out_sonames"; : > "$out_needed"; : > "$out_rpaths"
  local tool; tool="$(elf_tool)"
  if [[ -z "$tool" ]]; then
    warn "readelf/objdump ausente: ABI/SONAME detection desativada."
    return 0
  fi

  local f dump
  while IFS= read -r f; do
    dump="$(elf_dyn_dump "$f" || true)"
    [[ -n "$dump" ]] || continue
    if [[ "$tool" == "readelf" ]]; then
      printf "%s\n" "$dump" | awk -F'[][]' '/\(SONAME\)/{print $2}' >> "$out_sonames" || true
      printf "%s\n" "$dump" | awk -F'[][]' '/\(NEEDED\)/{print $2}' >> "$out_needed" || true
      printf "%s\n" "$dump" | awk -F'[][]' '/\(RPATH\)|\(RUNPATH\)/{print $2}' >> "$out_rpaths" || true
    else
      printf "%s\n" "$dump" | awk '/SONAME/{print $2}' >> "$out_sonames" || true
      printf "%s\n" "$dump" | awk '/NEEDED/{print $2}' >> "$out_needed" || true
      printf "%s\n" "$dump" | awk '/RPATH|RUNPATH/{print $2}' >> "$out_rpaths" || true
    fi
  done < <(find "$root" -type f 2>/dev/null | sort)

  sort -u -o "$out_sonames" "$out_sonames" 2>/dev/null || true
  sort -u -o "$out_needed" "$out_needed" 2>/dev/null || true
  sort -u -o "$out_rpaths" "$out_rpaths" 2>/dev/null || true
}

abi_removed_sonames() {
  local oldf="$1" newf="$2"
  [[ -f "$oldf" && -f "$newf" ]] || return 0
  comm -23 <(sort -u "$oldf") <(sort -u "$newf") 2>/dev/null || true
}

# ---------------- Owners DB ----------------
# owners.tsv: path<TAB>pkg
owners_get() { grep -F $'\t'"$1"$'\t' -n /dev/null 2>/dev/null; } # unused placeholder

owner_of() {
  local rel="$1"
  awk -F'\t' -v p="$rel" '$1==p{print $2}' "$PKG_OWNERS" 2>/dev/null | tail -n1 || true
}

owners_set_bulk() {
  # stdin: relpath\n ; arg1=pkg
  local pkg="$1"
  local tmp="${PKG_OWNERS}.tmp.$$"
  cp "$PKG_OWNERS" "$tmp" 2>/dev/null || : > "$tmp"
  local rel
  while IFS= read -r rel; do
    [[ -n "$rel" ]] || continue
    # remove entradas antigas do mesmo arquivo, depois adiciona nova
    awk -F'\t' -v p="$rel" '$1!=p' "$tmp" > "${tmp}.2" 2>/dev/null || true
    mv "${tmp}.2" "$tmp"
    printf "%s\t%s\n" "$rel" "$pkg" >> "$tmp"
  done
  sort -u -o "$tmp" "$tmp" 2>/dev/null || true
  [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] atualizar owners.tsv"; rm -f "$tmp"; return; }
  mv "$tmp" "$PKG_OWNERS"
}

owners_remove_pkg_entries() {
  local pkg="$1"
  local tmp="${PKG_OWNERS}.tmp.$$"
  awk -F'\t' -v p="$pkg" '$2!=p' "$PKG_OWNERS" > "$tmp" 2>/dev/null || : > "$tmp"
  [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] remover entradas owners para $pkg"; rm -f "$tmp"; return; }
  mv "$tmp" "$PKG_OWNERS"
}

# ---------------- Index ----------------
index_build() {
  mkdirs
  [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] gerar índice $PKG_INDEX"; return; }
  : > "$PKG_INDEX"
  local r pkg
  while IFS= read -r r; do
    pkg="$(basename "$r" .recipe)"
    recipe_load "$pkg"
    printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
      "$R_NAME" "$R_CATEGORY" "$R_VERSION" "$R_STAGE" \
      "${R_BDEPS[*]:-}" "${R_RDEPS[*]:-}" "$R_URL" >> "$PKG_INDEX"
  done < <(find "$PKG_RECIPES" -type f -name "*.recipe" 2>/dev/null | sort)
  ok "índice atualizado: $PKG_INDEX"
  registry "index" "" "count=$(wc -l < "$PKG_INDEX" 2>/dev/null || echo 0)"
}

index_ensure() { [[ -f "$PKG_INDEX" ]] || index_build; }

# Query com filtros:
#  - tokens sem prefixo: substring em name/cat/stage/dep
#  - name:foo cat:libs stage:cmake dep:zlib
cmd_search() {
  local query="${1:-}"; [[ -n "$query" ]] || die "uso: pkg search <query>"
  index_ensure

  local namef="" catf="" stagef="" depf="" free=()
  local tok
  for tok in $query; do
    case "$tok" in
      name:*) namef="${tok#name:}" ;;
      cat:*) catf="${tok#cat:}" ;;
      stage:*) stagef="${tok#stage:}" ;;
      dep:*) depf="${tok#dep:}" ;;
      *) free+=("$tok") ;;
    esac
  done

  awk -F'\t' -v namef="$namef" -v catf="$catf" -v stagef="$stagef" -v depf="$depf" -v free="${free[*]:-}" '
    BEGIN{IGNORECASE=1}
    function has_free(s, arr, n, i, t){
      n=split(free, arr, " ");
      for(i=1;i<=n;i++){ t=arr[i]; if(t=="" )continue; if(index(tolower(s), tolower(t))==0) return 0; }
      return 1;
    }
    {
      name=$1; cat=$2; ver=$3; stage=$4; bdeps=$5; rdeps=$6; url=$7;
      s=cat "/" name " " ver " " stage " " bdeps " " rdeps " " url;
      if(namef!="" && index(tolower(name), tolower(namef))==0) next;
      if(catf!="" && index(tolower(cat), tolower(catf))==0) next;
      if(stagef!="" && index(tolower(stage), tolower(stagef))==0) next;
      if(depf!="" && index(tolower(bdeps " " rdeps), tolower(depf))==0) next;
      if(free!="" && !has_free(s)) next;
      printf "%s/%s (%s) stage=%s bdeps=[%s] rdeps=[%s]\n", cat, name, ver, stage, bdeps, rdeps;
    }
  ' "$PKG_INDEX"
}

# ---------------- Fetch/cache ----------------
cmd_fetch_one() {
  local pkg="$1"
  recipe_load "$pkg"
  local dist; dist="$(distfile_path)"
  mkdirs
  if [[ -f "$dist" ]]; then
    ok "cache ok: $dist"
  else
    log "download: $R_URL"
    registry "fetch" "$pkg" "url=$R_URL"
    [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] download -> $dist"; return; }
    fetch_url "$R_URL" "$dist"
    ok "download ok: $dist"
  fi

  [[ "$PKG_DRY_RUN" == "1" ]] && { warn "sha256 pulado (dry-run)"; return; }
  [[ "$PKG_SKIP_SHA256" == "1" ]] && { warn "sha256 pulado"; return; }

  if [[ -n "$R_SHA256" ]]; then
    local got; got="$(sha256_of "$dist")"
    [[ "$got" == "$R_SHA256" ]] || die "sha256 inválido para $pkg. esperado=$R_SHA256 obtido=$got"
    ok "sha256 ok"
  else
    warn "recipe sem sha256 (recomendado preencher)."
  fi
}

ensure_source_cached() {
  local pkg="$1"
  recipe_load "$pkg"
  local cache; cache="$(source_cache_dir)"
  [[ -d "$cache" ]] && { log "source cache: $cache"; return; }

  cmd_fetch_one "$pkg"
  local dist; dist="$(distfile_path)"

  if [[ "$PKG_DRY_RUN" == "1" ]]; then
    log "[dry-run] criar source cache $cache"
    return
  fi

  local tmp; tmp="$(tmpdir_new)"
  local root="${tmp}/root"
  extract_archive "$dist" "$root"
  local srcdir; srcdir="$(find "$root" -mindepth 1 -maxdepth 1 -type d | head -n1 || true)"
  [[ -n "$srcdir" ]] || die "não encontrei diretório após extração."
  mkdir -p "$cache"
  rsync -a "$srcdir"/ "$cache"/
  chmod -R a-w "$cache" || true
  rm -rf "$tmp"
  ok "source cache criado: $cache"
}

cmd_fetch() {
  local target="${1:-}"; [[ -n "$target" ]] || die "uso: pkg fetch <pkg>|@world [--sources]"
  local with_sources="${2:-0}"
  if [[ "$target" == "@world" ]]; then
    while IFS= read -r p; do [[ -n "$p" ]] || continue; cmd_fetch "$p" "$with_sources"; done < "$PKG_WORLD"
    return
  fi
  if [[ "$with_sources" == "1" ]]; then ensure_source_cached "$target"; else cmd_fetch_one "$target"; fi
  ok "fetch ok: $target"
}

# ---------------- Hooks ----------------
run_hook() {
  local hook="$1" pkg="$2"
  local script="${PKG_HOOKS}/${hook}.sh"
  [[ -x "$script" ]] || return 0
  log "hook: $hook ($script) pkg=$pkg"
  [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] hook $hook"; return 0; }
  "$script" "$pkg" "$PKG_PREFIX" "$PKG_HOME" || warn "hook falhou: $hook"
}

# ---------------- Install with staged manifest + owners + ABI capture ----------------
stage_install_from_build() {
  local pkg="$1" stage="$2" bld="$3" src="$4"
  local stagedir; stagedir="$(tmpdir_new)"
  local prefix="$PKG_PREFIX"
  [[ "$prefix" == /* ]] || die "PKG_PREFIX deve ser absoluto."

  if [[ "$PKG_DRY_RUN" == "1" ]]; then
    log "[dry-run] instalar $pkg (stage=$stage)"
    rm -rf "$stagedir"
    return 0
  fi

  run_template "$stage" "$src" "$bld" "$stagedir"
  local sp="${stagedir}${prefix}"
  [[ -d "$sp" ]] || die "install não respeitou DESTDIR/prefixo. esperado: $sp"

  local manifest="${stagedir}/manifest.txt"
  (cd "$sp" && find . \( -type f -o -type l \) -print) | sed 's#^\./##' | sort > "$manifest"

  local sonames_new="${stagedir}/sonames.txt"
  local needed_new="${stagedir}/needed.txt"
  local rpaths_new="${stagedir}/rpaths.txt"
  elf_collect_abi "$sp" "$sonames_new" "$needed_new" "$rpaths_new"

  local old_pdb; old_pdb="$(pkg_dir "$pkg")"
  local sonames_old="${old_pdb}/sonames.txt"
  local abi_removed=()
  if [[ -f "$sonames_old" ]]; then
    while IFS= read -r s; do [[ -n "$s" ]] || continue; abi_removed+=("$s"); done < <(abi_removed_sonames "$sonames_old" "$sonames_new")
  fi

  # remove versão anterior (respeitando owners)
  if pkg_is_installed "$pkg"; then
    warn "reinstalando: removendo versão anterior"
    cmd_remove "$pkg"
  fi

  mkdir -p "$prefix"
  rsync -a "$sp"/ "$prefix"/

  # owners: todos arquivos do manifest passam a ser do pkg (com aviso de conflito)
  local conflicts=0
  while IFS= read -r rel; do
    [[ -n "$rel" ]] || continue
    local prev; prev="$(owner_of "$rel")"
    if [[ -n "$prev" && "$prev" != "$pkg" ]]; then
      warn "conflito: $rel era de $prev, agora será de $pkg"
      conflicts=$((conflicts+1))
    fi
  done < "$manifest"
  owners_set_bulk "$pkg" < "$manifest"

  local pdb; pdb="$(pkg_dir "$pkg")"
  mkdir -p "$pdb"
  printf "%s\n" "$pkg" > "$pdb/name"
  printf "%s\n" "$R_VERSION" > "$pdb/version"
  printf "%s\n" "$R_CATEGORY" > "$pdb/category"
  printf "%s\n" "$R_STAGE" > "$pdb/stage"
  printf "%s\n" "$R_URL" > "$pdb/url"
  printf "%s\n" "$(now)" > "$pdb/installed_at"
  printf "%s\n" "$VERSION" > "$pdb/pkg_version"
  printf "%s\n" "${R_BDEPS[*]:-}" > "$pdb/bdeps"
  printf "%s\n" "${R_RDEPS[*]:-}" > "$pdb/rdeps"
  cp "$manifest" "$pdb/manifest.txt"
  cp "$sonames_new" "$pdb/sonames.txt" 2>/dev/null || true
  cp "$needed_new" "$pdb/needed.txt" 2>/dev/null || true
  cp "$rpaths_new" "$pdb/rpaths.txt" 2>/dev/null || true

  rm -rf "$stagedir"
  ok "instalado: $pkg $R_VERSION"
  registry "install_ok" "$pkg" "version=$R_VERSION conflicts=$conflicts"

  # enviar SONAMEs removidos via fd3
  if [[ "${#abi_removed[@]}" -gt 0 ]]; then printf "%s\n" "${abi_removed[@]}" >&3; fi
  return 0
}

remove_files_from_manifest_owned() {
  local pkg="$1" manifest="$2"
  [[ -f "$manifest" ]] || die "manifest não encontrado: $manifest"
  local prefix="$PKG_PREFIX"

  if [[ "$PKG_DRY_RUN" == "1" ]]; then
    log "[dry-run] remover arquivos (owned) de $manifest"
    return
  fi

  local rel
  while IFS= read -r rel; do
    [[ -n "$rel" ]] || continue
    local owner; owner="$(owner_of "$rel")"
    if [[ "$owner" != "$pkg" ]]; then
      # não remover arquivos que agora pertencem a outro pacote
      continue
    fi
    rm -f "${prefix}/${rel}" 2>/dev/null || true
  done < "$manifest"

  # cleanup dirs (best-effort)
  local dirs
  dirs="$(awk -v p="$prefix" '{print p "/" $0}' "$manifest" | xargs -r -n1 dirname | sort -r | uniq)"
  while IFS= read -r d; do rmdir -p "$d" 2>/dev/null || true; done <<< "$dirs"
}

# ---------------- World ----------------
world_has() { grep -Fxq "$1" "$PKG_WORLD" 2>/dev/null; }
world_add() {
  local pkg="$1"
  mkdirs
  world_has "$pkg" && { ok "world já contém: $pkg"; return; }
  [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] world add $pkg"; return; }
  printf "%s\n" "$pkg" >> "$PKG_WORLD"
  sort -u -o "$PKG_WORLD" "$PKG_WORLD"
  ok "world add: $pkg"
}
world_rm() {
  local pkg="$1"
  mkdirs
  [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] world rm $pkg"; return; }
  grep -Fxv "$pkg" "$PKG_WORLD" > "${PKG_WORLD}.tmp" || true
  mv "${PKG_WORLD}.tmp" "$PKG_WORLD"
  ok "world rm: $pkg"
}
world_show() { mkdirs; cat "$PKG_WORLD" 2>/dev/null || true; }

# ---------------- Reverse-deps rebuild ----------------
revdeps_installed_closure() {
  local root="$1"
  graph_rebuild
  declare -A seen=()
  local q=("$root")
  seen["$root"]=1
  local out=()

  while [[ "${#q[@]}" -gt 0 ]]; do
    local cur="${q[0]}"; q=("${q[@]:1}")
    local f; f="$(graph_revdeps_file "$cur")"
    [[ -f "$f" ]] || continue
    while IFS= read -r r; do
      [[ -n "$r" ]] || continue
      [[ "${seen[$r]:-0}" -eq 1 ]] && continue
      seen["$r"]=1
      if pkg_is_installed "$r"; then
        out+=("$r")
        q+=("$r")
      fi
    done < "$f"
  done
  printf "%s\n" "${out[@]}" | sort -u
}

pkg_needed_has_any() {
  local pkg="$1"; shift
  local needed_file="$(pkg_dir "$pkg")/needed.txt"
  if [[ ! -f "$needed_file" ]]; then return 2; fi
  local s
  for s in "$@"; do grep -Fxq "$s" "$needed_file" && return 0; done
  return 1
}

rebuild_revdeps_for_removed_sonames() {
  local root="$1"; shift
  local removed_sonames=("$@")
  [[ "${#removed_sonames[@]}" -gt 0 ]] || return 0

  log "ABI/SONAME removidos em $root: ${removed_sonames[*]}"
  registry "abi_removed" "$root" "sonames=${removed_sonames[*]}"

  local closure=()
  while IFS= read -r p; do [[ -n "$p" ]] || continue; closure+=("$p"); done < <(revdeps_installed_closure "$root")
  [[ "${#closure[@]}" -gt 0 ]] || { ok "nenhum reverse-dep instalado para rebuild"; return 0; }

  local affected=() unknown=() p
  for p in "${closure[@]}"; do
    if pkg_needed_has_any "$p" "${removed_sonames[@]}"; then
      affected+=("$p")
    else
      local rc=$?
      [[ "$rc" -eq 2 ]] && unknown+=("$p")
    fi
  done
  if [[ "${#unknown[@]}" -gt 0 ]]; then
    warn "Sem DT_NEEDED registrado para: ${unknown[*]} (modo conservador: incluídos)"
    affected+=("${unknown[@]}")
  fi
  readarray -t affected < <(printf "%s\n" "${affected[@]}" | sort -u)

  [[ "${#affected[@]}" -gt 0 ]] || { ok "nenhum rebuild necessário (DT_NEEDED)."; return 0; }

  warn "Rebuild necessário: ${affected[*]}"
  confirm "Rebuild agora?" || { warn "Rebuild pendente (pkg rebuild $root --revdeps)"; return 0; }

  declare -A need=(); local plan=() x
  for p in "${affected[@]}"; do
    while IFS= read -r x; do
      [[ -n "$x" ]] || continue
      pkg_is_installed "$x" || continue
      [[ "$x" == "$root" ]] && continue
      if [[ "${need[$x]:-0}" -ne 1 ]]; then need["$x"]=1; plan+=("$x"); fi
    done < <(resolve_order "$p" "rebuild")
  done
  readarray -t plan < <(printf "%s\n" "${plan[@]}" | awk '!seen[$0]++')
  log "Plano rebuild: ${plan[*]}"
  for p in "${plan[@]}"; do cmd_build_install_one "$p" "rebuild"; done
  ok "rebuild revdeps concluído"
  registry "rebuild_revdeps_ok" "$root" "count=${#plan[@]}"
}

# ---------------- Build/Install orchestrator ----------------
cmd_build_install_one() {
  local pkg="$1"
  local reason="${2:-install}"
  recipe_load "$pkg"

  if is_locked "$pkg" && [[ "$reason" =~ ^(update|upgrade)$ ]]; then
    warn "lock: pulando $pkg (reason=$reason)"
    registry "skip_locked" "$pkg" "reason=$reason"
    return 0
  fi

  ensure_source_cached "$pkg"
  local cache; cache="$(source_cache_dir)"
  local work; work="$(tmpdir_new)"
  local src="${work}/src"
  local bld="${work}/build"
  local phase="${PKG_LOGS}/${pkg}-${R_VERSION}-${reason}-$(date +%Y%m%d-%H%M%S).log"
  local removed_file="${work}/abi_removed.txt"
  : > "$removed_file"

  local t0; t0="$(ts_epoch)"
  {
    log "==> $pkg ($R_VERSION) stage=$R_STAGE reason=$reason"
    if [[ "$PKG_DRY_RUN" == "1" ]]; then
      log "[dry-run] rsync cache -> $src ; build -> $bld ; install staged"
      return 0
    fi
    mkdir -p "$src"
    rsync -a "$cache"/ "$src"/
    exec 3> "$removed_file"
    stage_install_from_build "$pkg" "$R_STAGE" "$bld" "$src" 3>&3
    exec 3>&-
  } 2>&1 | tee "$phase"
  local t1; t1="$(ts_epoch)"
  registry "metric" "$pkg" "seconds=$((t1-t0)) reason=$reason"

  if [[ "$PKG_DRY_RUN" != "1" ]]; then rm -rf "$work"; fi

  if [[ -s "$removed_file" ]]; then
    mkdir -p "$(pkg_dir "$pkg")"
    cp "$removed_file" "$(pkg_dir "$pkg")/abi_removed_last.txt" 2>/dev/null || true
  fi

  run_hook "post-install" "$pkg"
  return 0
}

cmd_install() {
  local target="${1:-}"; [[ -n "$target" ]] || die "uso: pkg install <pkg>|@world"
  registry "install" "$target" "dry=$PKG_DRY_RUN"
  if [[ "$target" == "@world" ]]; then
    while IFS= read -r p; do [[ -n "$p" ]] || continue; cmd_install "$p"; done < "$PKG_WORLD"
    return
  fi

  local plan=()
  while IFS= read -r p; do plan+=("$p"); done < <(resolve_order "$target" "install")
  log "Plano: ${plan[*]}"

  local p
  for p in "${plan[@]}"; do
    pkg_is_installed "$p" && { ok "já instalado: $p"; continue; }
    cmd_build_install_one "$p" "install"
  done

  world_add "$target"
  ok "install concluído: $target"
}

cmd_update() {
  local target="${1:-}"; [[ -n "$target" ]] || die "uso: pkg update <pkg>|@world"
  registry "update" "$target" "dry=$PKG_DRY_RUN"
  if [[ "$target" == "@world" ]]; then
    while IFS= read -r p; do [[ -n "$p" ]] || continue; cmd_update "$p"; done < "$PKG_WORLD"
    return
  fi

  local plan=()
  while IFS= read -r p; do plan+=("$p"); done < <(resolve_order "$target" "update")
  log "Plano: ${plan[*]}"

  local p
  for p in "${plan[@]}"; do
    if ! pkg_is_installed "$p"; then
      cmd_build_install_one "$p" "install"
      continue
    fi
    if needs_update "$p"; then
      warn "update: $p (cur=$(installed_version "$p") -> new=$(effective_version "$p"))"
      cmd_build_install_one "$p" "update"
      if [[ "$PKG_REBUILD_POLICY" == "auto" ]]; then
        local removed_file="$(pkg_dir "$p")/abi_removed_last.txt"
        if [[ -f "$removed_file" && -s "$removed_file" ]]; then
          readarray -t removed < "$removed_file"
          rebuild_revdeps_for_removed_sonames "$p" "${removed[@]}"
        fi
      fi
    else
      ok "ok: $p (sem mudanças)"
    fi
  done
  ok "update concluído: $target"
}

cmd_upgrade() {
  local target="${1:-@world}"
  local waves="${2:-$PKG_WAVES}"
  local no_rebuild="${3:-0}"

  [[ "$target" == "@world" ]] || die "uso: pkg upgrade [@world] ..."
  registry "upgrade" "@world" "waves=$waves norebuild=$no_rebuild dry=$PKG_DRY_RUN"

  # política simples por waves: agrupar pelo prefixo de categoria
  # wave 'toolchain': categoria contém 'toolchain'
  # wave 'libs': categoria contém 'lib' ou 'libs'
  # wave 'apps': resto
  declare -a world=()
  while IFS= read -r p; do [[ -n "$p" ]] || continue; world+=("$p"); done < "$PKG_WORLD"
  [[ "${#world[@]}" -gt 0 ]] || { ok "world vazio"; return; }

  local wave
  IFS=',' read -r -a wave_list <<< "$waves"
  for wave in "${wave_list[@]}"; do
    local bucket=()
    local p
    for p in "${world[@]}"; do
      recipe_load "$p"
      case "$wave" in
        toolchain) [[ "$R_CATEGORY" == *toolchain* ]] && bucket+=("$p") ;;
        libs) [[ "$R_CATEGORY" == *lib* ]] && bucket+=("$p") ;;
        apps) [[ "$R_CATEGORY" != *toolchain* && "$R_CATEGORY" != *lib* ]] && bucket+=("$p") ;;
        *) : ;;
      esac
    done
    [[ "${#bucket[@]}" -eq 0 ]] && continue
    log "=== wave: $wave ==="
    for p in "${bucket[@]}"; do
      if [[ "$no_rebuild" == "1" ]]; then
        local old="$PKG_REBUILD_POLICY"
        PKG_REBUILD_POLICY="never"
        cmd_update "$p"
        PKG_REBUILD_POLICY="$old"
      else
        cmd_update "$p"
      fi
    done
  done
  ok "upgrade concluído"
}

cmd_rebuild() {
  local pkg="${1:-}"; [[ -n "$pkg" ]] || die "uso: pkg rebuild <pkg> [--revdeps|--all-revdeps]"
  local rev="${2:-0}" all="${3:-0}"
  registry "rebuild" "$pkg" "revdeps=$rev all=$all dry=$PKG_DRY_RUN"

  cmd_build_install_one "$pkg" "rebuild"

  [[ "$rev" == "1" ]] || { ok "rebuild concluído: $pkg"; return; }

  if [[ "$all" == "1" ]]; then
    local closure=()
    while IFS= read -r p; do [[ -n "$p" ]] || continue; closure+=("$p"); done < <(revdeps_installed_closure "$pkg")
    [[ "${#closure[@]}" -gt 0 ]] || { ok "nenhum reverse-dep instalado"; return; }
    warn "Rebuild forçado (todos revdeps): ${closure[*]}"
    confirm "Rebuild agora?" || die "cancelado"
    local p
    for p in "${closure[@]}"; do cmd_build_install_one "$p" "rebuild"; done
    ok "rebuild revdeps concluído"
    return
  fi

  local removed_file="$(pkg_dir "$pkg")/abi_removed_last.txt"
  if [[ -f "$removed_file" && -s "$removed_file" ]]; then
    readarray -t removed < "$removed_file"
    rebuild_revdeps_for_removed_sonames "$pkg" "${removed[@]}"
  else
    warn "Sem evidência de SONAME removido para $pkg. Use --all-revdeps para forçar."
  fi
}

cmd_remove() {
  local pkg="${1:-}"; [[ -n "$pkg" ]] || die "uso: pkg remove <pkg>"
  local pdb; pdb="$(pkg_dir "$pkg")"
  local manifest="${pdb}/manifest.txt"
  [[ -f "$manifest" ]] || die "não instalado: $pkg"

  registry "remove" "$pkg" "dry=$PKG_DRY_RUN"
  remove_files_from_manifest_owned "$pkg" "$manifest"
  owners_remove_pkg_entries "$pkg"
  [[ "$PKG_DRY_RUN" == "1" ]] || rm -rf "$pdb"
  world_rm "$pkg"
  run_hook "post-remove" "$pkg"
  ok "removido: $pkg"
}

cmd_autoremove() {
  declare -A need=()
  while IFS= read -r w; do
    [[ -n "$w" ]] || continue
    while IFS= read -r p; do need["$p"]=1; done < <(resolve_order "$w" "install")
  done < "$PKG_WORLD"

  local d pkg
  local rm=()
  for d in "$PKG_DB"/*; do
    [[ -d "$d" ]] || continue
    pkg="$(cat "$d/name" 2>/dev/null || basename "$d")"
    [[ "${need[$pkg]:-0}" -eq 1 ]] || rm+=("$pkg")
  done
  [[ "${#rm[@]}" -gt 0 ]] || { ok "nenhum órfão"; return; }

  warn "Órfãos: ${rm[*]}"
  confirm "Remover órfãos?" || die "cancelado"
  local p; for p in "${rm[@]}"; do cmd_remove "$p"; done
}

cmd_clean() {
  local what="${1:-}"; [[ -n "$what" ]] || die "uso: pkg clean <pkg>|all"
  if [[ "$what" == "all" ]]; then
    [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] limpar workdirs"; return; }
    rm -rf "$PKG_BUILD_ROOT"/.tmp.* 2>/dev/null || true
    ok "workdirs limpos"
    return
  fi
  recipe_load "$what"
  local dist; dist="$(distfile_path)"
  local src; src="$(source_cache_dir)"
  [[ "$PKG_DRY_RUN" == "1" ]] && { log "[dry-run] rm $dist ; rm -rf $src"; return; }
  rm -f "$dist" 2>/dev/null || true
  rm -rf "$src" 2>/dev/null || true
  ok "limpo: $what"
}

cmd_list() {
  printf "%-22s %-10s %-12s %-18s\n" "PACOTE" "VERSÃO" "CATEGORIA" "INSTALADO"
  printf "%-22s %-10s %-12s %-18s\n" "------" "------" "---------" "--------"
  local d
  for d in "$PKG_DB"/*; do
    [[ -d "$d" ]] || continue
    local n v c t
    n="$(cat "$d/name" 2>/dev/null || basename "$d")"
    v="$(cat "$d/version" 2>/dev/null || echo "?")"
    c="$(cat "$d/category" 2>/dev/null || echo "?")"
    t="$(cat "$d/installed_at" 2>/dev/null || echo "?")"
    printf "%-22s %-10s %-12s %-18s\n" "$n" "$v" "$c" "${t:0:19}"
  done
}

cmd_info() {
  local pkg="${1:-}"; [[ -n "$pkg" ]] || die "uso: pkg info <pkg>"
  if pkg_is_installed "$pkg"; then
    local pdb; pdb="$(pkg_dir "$pkg")"
    echo "Pacote:    $(cat "$pdb/name")"
    echo "Versão:    $(cat "$pdb/version")"
    echo "Categoria: $(cat "$pdb/category")"
    echo "Stage:     $(cat "$pdb/stage")"
    echo "URL:       $(cat "$pdb/url")"
    echo "BDeps:     $(cat "$pdb/bdeps" 2>/dev/null || true)"
    echo "RDeps:     $(cat "$pdb/rdeps" 2>/dev/null || true)"
    echo "Instalado: $(cat "$pdb/installed_at")"
    [[ -f "$pdb/sonames.txt" ]] && echo "SONAMEs:   $(tr '\n' ' ' < "$pdb/sonames.txt" | sed 's/[[:space:]]*$//')"
    echo "Manifest:  $pdb/manifest.txt"
  else
    recipe_load "$pkg"
    echo "Recipe:    $R_PATH"
    echo "Versão:    $R_VERSION"
    echo "Categoria: $R_CATEGORY"
    echo "Stage:     $R_STAGE"
    echo "URL:       $R_URL"
    echo "BDeps:     ${R_BDEPS[*]:-}"
    echo "RDeps:     ${R_RDEPS[*]:-}"
    local lk; lk="$(lock_get "$pkg" 2>/dev/null || true)"
    [[ -n "$lk" ]] && echo "Lock:      $lk"
  fi
}

cmd_plan() {
  local target="${1:-}"; [[ -n "$target" ]] || die "uso: pkg plan <pkg>|@world"
  if [[ "$target" == "@world" ]]; then
    while IFS= read -r p; do [[ -n "$p" ]] || continue; echo "== $p =="; resolve_order "$p" "install"; done < "$PKG_WORLD"
    return
  fi
  resolve_order "$target" "install"
}

cmd_explain() {
  local pkg="${1:-}"; [[ -n "$pkg" ]] || die "uso: pkg explain <pkg> [--tree]"
  local tree="${2:-0}"
  recipe_load "$pkg"
  echo "Pacote: $pkg"
  echo "  categoria: $R_CATEGORY"
  echo "  stage:     $R_STAGE"
  echo "  bdeps:     ${R_BDEPS[*]:-}"
  echo "  rdeps:     ${R_RDEPS[*]:-}"
  if [[ "$tree" != "1" ]]; then return; fi
  echo
  echo "Árvore (bdeps+rdeps):"
  local indent=""
  declare -A seen=()
  explain_tree() {
    local p="$1" depth="$2"
    [[ "${seen[$p]:-0}" -eq 1 ]] && { printf "%*s- %s (repetido)\n" $((depth*2)) "" "$p"; return; }
    seen["$p"]=1
    recipe_load "$p"
    printf "%*s- %s\n" $((depth*2)) "" "$p"
    local d
    for d in "${R_BDEPS[@]:-}"; do explain_tree "$d" $((depth+1)); done
    for d in "${R_RDEPS[@]:-}"; do explain_tree "$d" $((depth+1)); done
  }
  explain_tree "$pkg" 0
}

# ---------------- Check / Verify ----------------
cmd_check_one() {
  local pkg="$1"
  local pdb="$(pkg_dir "$pkg")"
  local manifest="$pdb/manifest.txt"
  [[ -f "$manifest" ]] || { warn "não instalado: $pkg"; return 0; }

  local missing=0
  while IFS= read -r rel; do
    [[ -n "$rel" ]] || continue
    if [[ ! -e "$PKG_PREFIX/$rel" ]]; then
      warn "faltando: $pkg -> $rel"
      missing=$((missing+1))
    fi
  done < "$manifest"

  # libs quebradas via ldd (best-effort)
  if have_cmd ldd; then
    local f
    while IFS= read -r rel; do
      [[ -n "$rel" ]] || continue
      f="$PKG_PREFIX/$rel"
      [[ -f "$f" ]] || continue
      # ldd em arquivos não-ELF retorna erro rápido; ignorar
      if ldd "$f" 2>/dev/null | grep -q "not found"; then
        warn "ldd not found: $pkg -> $rel"
      fi
    done < "$manifest"
  fi

  # RPATH fora do prefix (best-effort)
  local rpf="$pdb/rpaths.txt"
  if [[ -f "$rpf" && -s "$rpf" ]]; then
    local rp
    while IFS= read -r rp; do
      [[ -n "$rp" ]] || continue
      if [[ "$rp" == *"/usr/lib"* || "$rp" == *"/lib"* ]]; then
        warn "RPATH suspeito ($pkg): $rp"
      fi
    done < "$rpf"
  fi

  [[ "$missing" -eq 0 ]] && ok "check ok: $pkg" || warn "check: $pkg missing=$missing"
}

cmd_check() {
  local target="${1:-@world}"
  if [[ "$target" == "@world" ]]; then
    local p
    for p in "$PKG_DB"/*; do
      [[ -d "$p" ]] || continue
      cmd_check_one "$(basename "$p")"
    done
    return
  fi
  cmd_check_one "$target"
}

cmd_verify_distfiles() {
  index_ensure
  local bad=0
  awk -F'\t' '{print $1"\t"$3}' "$PKG_INDEX" | while IFS=$'\t' read -r name ver; do
    [[ -n "$name" ]] || continue
    recipe_load "$name"
    local dist; dist="$(distfile_path)"
    if [[ ! -f "$dist" ]]; then
      continue
    fi
    if [[ "$PKG_SKIP_SHA256" == "1" ]]; then continue; fi
    if [[ -n "$R_SHA256" ]]; then
      local got; got="$(sha256_of "$dist")"
      if [[ "$got" != "$R_SHA256" ]]; then
        warn "distfile sha256 inválido: $name ($dist)"
        bad=$((bad+1))
      fi
    fi
  done
  [[ "$bad" -eq 0 ]] && ok "verify distfiles ok" || warn "verify distfiles falhas=$bad"
}

cmd_verify_prefix() {
  local bad=0
  while IFS=$'\t' read -r rel owner; do
    [[ -n "$rel" ]] || continue
    if [[ ! -e "$PKG_PREFIX/$rel" ]]; then
      warn "prefix missing: $rel (owner=$owner)"
      bad=$((bad+1))
    fi
  done < "$PKG_OWNERS"
  [[ "$bad" -eq 0 ]] && ok "verify prefix ok" || warn "verify prefix falhas=$bad"
}

cmd_verify() {
  local what="${1:-all}"
  case "$what" in
    distfiles) cmd_verify_distfiles ;;
    prefix) cmd_verify_prefix ;;
    all) cmd_verify_distfiles; cmd_verify_prefix ;;
    *) die "uso: pkg verify distfiles|prefix|all" ;;
  esac
}

# ---------------- Init / Index ----------------
cmd_init() {
  mkdirs
  mkdir -p "$PKG_RECIPES/examples" "$PKG_RECIPES/toolchain" "$PKG_RECIPES/libs" "$PKG_RECIPES/apps"

  cat > "$PKG_RECIPES/libs/zlib.recipe" <<'R'
name=zlib
version=1.3.1
url=https://zlib.net/zlib-1.3.1.tar.gz
sha256=38ef96b8dfe510d42707d9c781877914792541133e1870841463bfa73f883e32
stage=make
bdeps=
rdeps=
R

  cat > "$PKG_RECIPES/examples/hello.recipe" <<'R'
name=hello
version=2.12.1
url=https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz
sha256=8d99142afd9254a3432f7c6c43f6f10a4a1d3e2f39f2f2c8a3f2e7d22d8c6104
stage=autotools
bdeps=
rdeps=
R

  cat > "$PKG_RECIPES/toolchain/binutils.recipe" <<'R'
name=binutils
version=2.42
url=https://ftp.gnu.org/gnu/binutils/binutils-2.42.tar.xz
sha256=bb64a8813d1a4e6ed73a01ea2f0b2b0f6b8d1caa1b6a6d5dbf5d6f2b7f99c3d5
stage=binutils
bdeps=
rdeps=
R

  cat > "$PKG_RECIPES/toolchain/musl.recipe" <<'R'
name=musl
version=1.2.5
url=https://musl.libc.org/releases/musl-1.2.5.tar.gz
sha256=a9a118b2c3d57b9279d709bf0c6f8e7a18aa4fe7f6a34a90c7c88a0cc3a65d89
stage=libc-musl
bdeps=
rdeps=
R

  ok "Inicializado."
  index_build
  registry "init" "" ""
}

cmd_index() {
  if [[ "${1:-}" == "1" ]]; then index_build; else index_ensure; ok "index ok: $PKG_INDEX"; fi
}

# ---------------- Doctor / Env ----------------
cmd_doctor() {
  mkdirs
  log "Checando ferramentas..."
  need_cmd bash; need_cmd tar; need_cmd rsync
  have_cmd flock || warn "flock ausente (lock pode falhar)"
  if ! have_cmd curl && ! have_cmd wget; then die "instale curl ou wget"; fi
  have_cmd make || warn "make ausente"
  have_cmd gcc || warn "gcc host ausente (bootstrap inicial exige)"
  have_cmd readelf || have_cmd objdump || warn "readelf/objdump ausente (ABI/SONAME detection desativada)"
  have_cmd ldd || warn "ldd ausente (check libs quebradas limitado)"
  ok "OK (avisos podem existir)"
  log "PKG_HOME=$PKG_HOME"
  log "PKG_PREFIX=$PKG_PREFIX"
  log "PKG_TARGET=${PKG_TARGET:-<none>}"
  log "PKG_SYSROOT=${PKG_SYSROOT:-<none>}"
}

cmd_env() {
  cat <<EOF
export PKG_PREFIX="${PKG_PREFIX}"
export PATH="\$PKG_PREFIX/bin:\$PATH"
export PKG_CONFIG_PATH="\$PKG_PREFIX/lib/pkgconfig:\$PKG_PREFIX/share/pkgconfig:\$PKG_CONFIG_PATH"
export LD_LIBRARY_PATH="\$PKG_PREFIX/lib:\$PKG_PREFIX/lib64:\$LD_LIBRARY_PATH"
export CMAKE_PREFIX_PATH="\$PKG_PREFIX:\$CMAKE_PREFIX_PATH"
EOF
  if [[ -n "${PKG_TARGET}" ]]; then
    echo "export PKG_TARGET=\"${PKG_TARGET}\""
  fi
  if [[ -n "${PKG_SYSROOT}" ]]; then
    echo "export PKG_SYSROOT=\"${PKG_SYSROOT}\""
  fi
}

# ---------------- Shortcuts ----------------
translate_shortcuts() {
  local args=("$@"); local out=(); local i=0
  while [[ $i -lt ${#args[@]} ]]; do
    case "${args[$i]}" in
      -n) out+=("--dry-run") ;;
      -S) out+=("--skip-sha256") ;;
      -i) out+=("install"); i=$((i+1)); out+=("${args[$i]:-}") ;;
      -u) out+=("update"); i=$((i+1)); out+=("${args[$i]:-}") ;;
      -r) out+=("remove"); i=$((i+1)); out+=("${args[$i]:-}") ;;
      -l) out+=("list") ;;
      -I) out+=("info"); i=$((i+1)); out+=("${args[$i]:-}") ;;
      -s) out+=("search"); i=$((i+1)); out+=("${args[$i]:-}") ;;
      *) out+=("${args[$i]}") ;;
    esac
    i=$((i+1))
  done
  printf "%s\n" "${out[@]}"
}

main() {
  local argv=("$@")
  if [[ "${#argv[@]}" -gt 0 && "${argv[0]}" == -* ]]; then mapfile -t argv < <(translate_shortcuts "${argv[@]}"); fi

  local cmd="${argv[0]:-}"
  case "$cmd" in -h|--help|help|"") usage; exit 0 ;; --version) echo "$VERSION"; exit 0 ;; esac

  lock_acquire
  start_logging

  local rest=() a
  for a in "${argv[@]}"; do
    case "$a" in
      --dry-run) PKG_DRY_RUN="1" ;;
      --skip-sha256) PKG_SKIP_SHA256="1" ;;
      --yes|-y) PKG_ASSUME_YES="1" ;;
      --no-rebuild) PKG_REBUILD_POLICY="never" ;;
      *) rest+=("$a") ;;
    esac
  done

  cmd="${rest[0]:-}"
  registry "cmd" "" "$cmd"

  case "$cmd" in
    init) cmd_init ;;
    index) [[ "${rest[1]:-}" == "--refresh" ]] && cmd_index "1" || cmd_index "0" ;;
    fetch)
      local with_sources="0" tgt=""
      if [[ "${rest[1]:-}" == "--sources" ]]; then with_sources="1"; tgt="${rest[2]:-}"
      elif [[ "${rest[2]:-}" == "--sources" ]]; then with_sources="1"; tgt="${rest[1]:-}"
      else tgt="${rest[1]:-}"
      fi
      cmd_fetch "$tgt" "$with_sources" ;;
    install) cmd_install "${rest[1]:-}" ;;
    update) cmd_update "${rest[1]:-}" ;;
    upgrade)
      local waves="$PKG_WAVES" noreb="0"
      local i=1
      while [[ $i -lt ${#rest[@]} ]]; do
        case "${rest[$i]}" in
          --waves) i=$((i+1)); waves="${rest[$i]:-$PKG_WAVES}" ;;
          --no-rebuild) noreb="1" ;;
        esac
        i=$((i+1))
      done
      cmd_upgrade "@world" "$waves" "$noreb" ;;
    rebuild)
      local pkg="${rest[1]:-}" rev="0" all="0" i=2
      while [[ $i -lt ${#rest[@]} ]]; do
        case "${rest[$i]}" in
          --revdeps) rev="1" ;;
          --all-revdeps) rev="1"; all="1" ;;
        esac
        i=$((i+1))
      done
      cmd_rebuild "$pkg" "$rev" "$all" ;;
    remove|rm|uninstall) cmd_remove "${rest[1]:-}" ;;
    list|ls) cmd_list ;;
    info) cmd_info "${rest[1]:-}" ;;
    search) cmd_search "${rest[1]:-}" ;;
    explain)
      if [[ "${rest[2]:-}" == "--tree" ]]; then cmd_explain "${rest[1]:-}" "1"; else cmd_explain "${rest[1]:-}" "0"; fi ;;
    plan) cmd_plan "${rest[1]:-}" ;;
    autoremove) cmd_autoremove ;;
    clean) cmd_clean "${rest[1]:-}" ;;
    check) cmd_check "${rest[1]:-@world}" ;;
    verify) cmd_verify "${rest[1]:-all}" ;;
    doctor) cmd_doctor ;;
    env) cmd_env ;;
    *) die "comando desconhecido: $cmd (use --help)" ;;
  esac
}

main "$@"
